
# --- Start of tests ---

# Python version we're using to run tests.
python -V
Python 3.6.3

# Error invocations.
procdog blah || expect_error
usage: procdog [-h] [-c COMMAND] [--health-command HEALTH_COMMAND]
               [--health-count HEALTH_COUNT] [--health-delay HEALTH_DELAY]
               [--ensure-healthy] [--dir DIR] [--stdin STDIN]
               [--stdout STDOUT] [--stderr STDERR] [--append]
               [--linger LINGER] [--strict] [--shell] [--config CONFIG]
               [--debug] [--version]
               {start,status,wait,stop} proc_name
procdog: error: argument control_cmd: invalid choice: 'blah' (choose from 'start', 'status', 'wait', 'stop')
(got expected error: status 2)

procdog status || expect_error
usage: procdog [-h] [-c COMMAND] [--health-command HEALTH_COMMAND]
               [--health-count HEALTH_COUNT] [--health-delay HEALTH_DELAY]
               [--ensure-healthy] [--dir DIR] [--stdin STDIN]
               [--stdout STDOUT] [--stderr STDERR] [--append]
               [--linger LINGER] [--strict] [--shell] [--config CONFIG]
               [--debug] [--version]
               {start,status,wait,stop} proc_name
procdog: error: the following arguments are required: proc_name
(got expected error: status 2)

procdog status foo@bar || expect_error
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
usage: procdog [-h] [-c COMMAND] [--health-command HEALTH_COMMAND]
               [--health-count HEALTH_COUNT] [--health-delay HEALTH_DELAY]
               [--ensure-healthy] [--dir DIR] [--stdin STDIN]
               [--stdout STDOUT] [--stderr STDERR] [--append]
               [--linger LINGER] [--strict] [--shell] [--config CONFIG]
               [--debug] [--version]
               {start,status,wait,stop} proc_name
procdog: error: Invalid process name 'foo@bar'; must be alphanumeric, with only underscores or dashes
(got expected error: status 2)

# Start, stop, and status on a long-lived process.
procdog status long || expect_error
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: exit code 5 (based on 'stopped' with strict=False and ensure_healthy=False)
stopped
(got expected error: status 5)

procdog wait long || expect_error
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: exit code 6 (based on 'stopped' with strict=False and ensure_healthy=False)
stopped
(got expected error: status 6)

procdog start long --command "sleep 5" --health-command "true"
procdog (_PID_): debug: command-line options: {'command': 'sleep 5', 'health_command': 'true'}
procdog (_PID_): debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.long.lock
procdog (_PID_): debug: command-line options: {'command': 'sleep 5', 'health_command': 'true'}
procdog (_PID_): debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.long.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=0, pid=_PID_
sleep 2

# Check sock and lock files.
ls -1 /var/tmp/procdog.long.*
/var/tmp/procdog.long.lock
/var/tmp/procdog.long.sock

procdog status long
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=0, pid=_PID_

procdog wait long
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: wait: running, health=0, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=0, pid=_PID_

procdog start long --command "sleep 5" --health-command "true"
procdog (_PID_): debug: command-line options: {'command': 'sleep 5', 'health_command': 'true'}
procdog (_PID_): debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: False: /var/tmp/procdog.long.lock
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=0, pid=_PID_

procdog start long --command "sleep 5" --health-command "true" --strict || expect_error
procdog (_PID_): debug: command-line options: {'command': 'sleep 5', 'health_command': 'true', 'strict': True}
procdog (_PID_): debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: False: /var/tmp/procdog.long.lock
procdog: error: process 'long' is already running
Traceback (most recent call last):
  File ".../procdog", line __X, in main
    response = _execute(args.proc_name, args.control_cmd, options)
  File ".../procdog", line __X, in _execute
    response = start(proc_name, options.command, options=options, strict=options.strict)
  File ".../procdog", line __X, in start
    raise AlreadyRunningException("process already running (to override, remove lock at %s)" % lock_path)
AlreadyRunningException: process already running (to override, remove lock at /var/tmp/procdog.long.lock)
(got expected error: status 4)

procdog stop long
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=False and ensure_healthy=False)
killed, signal=15

ls -1 /var/tmp/procdog.long.*
/var/tmp/procdog.long.sock

procdog stop long
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: exited, returncode=-15
procdog (_PID_): debug: client: exit code 0 (based on 'exited, returncode=-15' with strict=False and ensure_healthy=False)
exited, returncode=-15

procdog stop long --strict || expect_error
procdog (_PID_): debug: command-line options: {'strict': True}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: exited, returncode=-15
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=-15' with strict=True and ensure_healthy=False)
exited, returncode=-15
(got expected error: status 5)
sleep 4
procdog (_PID_): debug: command-line options: {'command': 'sleep 5', 'health_command': 'true'}
procdog (_PID_): debug: combined options: Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.long.lock
procdog (_PID_): monitor: starting with Options(command='sleep 5', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.long.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check: result: 0
procdog (_PID_): monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check: result: 0
procdog (_PID_): monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check: result: 0
procdog (_PID_): monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'wait'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check 0: result: 0
procdog (_PID_): monitor: command 'wait': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check: result: 0
procdog (_PID_): monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: command 'stop': response 'exited, returncode=-15'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: command 'stop': response 'exited, returncode=-15'

# Start and stop a shell script, to test process groups.
cat > ./sample-script.sh <<EOF
#!/bin/bash
sleep 200
EOF
chmod +x ./sample-script.sh

procdog start script --command "./sample-script.sh"
procdog (_PID_): debug: command-line options: {'command': './sample-script.sh'}
procdog (_PID_): debug: combined options: Options(command='./sample-script.sh', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.script.lock
procdog (_PID_): debug: command-line options: {'command': './sample-script.sh'}
procdog (_PID_): debug: combined options: Options(command='./sample-script.sh', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.script.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, pid=_PID_' with strict=False and ensure_healthy=False)
running, pid=_PID_

procdog stop script
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=False and ensure_healthy=False)
killed, signal=15

pgrep -q -f "sleep 200" && echo "still running" || echo "process done"
process done

# Start, stop, and status on a short-lived process.
procdog status short || expect_error
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: exit code 5 (based on 'stopped' with strict=False and ensure_healthy=False)
stopped
(got expected error: status 5)

procdog start short --command "sleep 1"
procdog (_PID_): debug: command-line options: {'command': 'sleep 1'}
procdog (_PID_): debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.short.lock
procdog (_PID_): debug: command-line options: {'command': 'sleep 1'}
procdog (_PID_): debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.short.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, pid=_PID_' with strict=False and ensure_healthy=False)
running, pid=_PID_
sleep 2

procdog status short || expect_error
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=0' with strict=False and ensure_healthy=False)
exited, returncode=0
(got expected error: status 5)

procdog start short --command "sleep 1" --strict
procdog (_PID_): debug: command-line options: {'command': 'sleep 1', 'strict': True}
procdog (_PID_): debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.short.lock
procdog (_PID_): debug: command-line options: {'command': 'sleep 1', 'strict': True}
procdog (_PID_): debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.short.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, pid=_PID_' with strict=True and ensure_healthy=False)
running, pid=_PID_

procdog stop short
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=False and ensure_healthy=False)
killed, signal=15

procdog stop short --strict || expect_error
procdog (_PID_): debug: command-line options: {'command': './sample-script.sh'}
procdog (_PID_): debug: combined options: Options(command='./sample-script.sh', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.script.lock
procdog (_PID_): monitor: starting with Options(command='./sample-script.sh', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.script.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'running, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'running, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
procdog (_PID_): debug: command-line options: {'strict': True}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: exited, returncode=-15
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=-15' with strict=True and ensure_healthy=False)
exited, returncode=-15
(got expected error: status 5)

# A long-lived unhealthy process.
procdog wait unhealthy1 || expect_error
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: exit code 6 (based on 'stopped' with strict=False and ensure_healthy=False)
stopped
(got expected error: status 6)

procdog start unhealthy1 --command "sleep 100" --health-command "false"
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'false'}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.unhealthy1.lock
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'false'}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.unhealthy1.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=1, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=1, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=1, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=1, pid=_PID_

procdog wait unhealthy1 || expect_error
procdog (_PID_): debug: command-line options: {'command': 'sleep 1'}
procdog (_PID_): debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.short.lock
procdog (_PID_): monitor: starting with Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.short.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'running, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'running, pid=_PID_'
procdog (_PID_): monitor: process done (code 0), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: command-line options: {'command': 'sleep 1', 'strict': True}
procdog (_PID_): debug: combined options: Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.short.lock
procdog (_PID_): monitor: starting with Options(command='sleep 1', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.short.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'running, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'running, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: command 'stop': response 'exited, returncode=-15'
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: wait: running, health=1, pid=_PID_
procdog (_PID_): debug: client: exit code 6 (based on 'running, health=1, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=1, pid=_PID_
(got expected error: status 6)

procdog stop unhealthy1
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=False and ensure_healthy=False)
killed, signal=15

# Test --ensure-healthy.
procdog start ensure1 --command "sleep 100" --health-command "true" --ensure-healthy
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'true', 'ensure_healthy': True}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.ensure1.lock
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'true', 'ensure_healthy': True}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.ensure1.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: monitor: ensure_healthy is set, waiting for health
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: wait: running, health=0, pid=_PID_
procdog (_PID_): debug: monitor: ensure_healthy is set and process is still healthy (running, health=0, pid=_PID_)
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=True)
running, health=0, pid=_PID_

procdog stop ensure1
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=False and ensure_healthy=False)
killed, signal=15

procdog start ensure2 --command "sleep 100" --health-command "false" --ensure-healthy || expect_error
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'false', 'ensure_healthy': True}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.ensure2.lock
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'false'}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.unhealthy1.lock
procdog (_PID_): monitor: starting with Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.unhealthy1.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check: result: 1
procdog (_PID_): monitor: command 'status': response 'running, health=1, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check: result: 1
procdog (_PID_): monitor: command 'status': response 'running, health=1, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'wait'
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 0: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 1: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 2: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 3: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 4: result: 1
procdog (_PID_): monitor: command 'wait': response 'running, health=1, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'true', 'ensure_healthy': True}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.ensure1.lock
procdog (_PID_): monitor: starting with Options(command='sleep 100', health_command='true', health_count=5, health_delay=1.0, ensure_healthy=True, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.ensure1.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check: result: 0
procdog (_PID_): monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'wait'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check 0: result: 0
procdog (_PID_): monitor: command 'wait': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'false', 'ensure_healthy': True}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.ensure2.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=1, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: monitor: ensure_healthy is set, waiting for health
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: wait: running, health=1, pid=_PID_
procdog (_PID_): debug: monitor: ensure_healthy is set and process is still not healthy (running, health=1, pid=_PID_); stopping
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 6 (based on 'killed, signal=15' with strict=False and ensure_healthy=True)
killed, signal=15
(got expected error: status 6)

# Test that a slow health check doesn't affect listening.
procdog start slow-health --command "sleep 100" --health-command "sleep 4" >/dev/null 2>&1 &

# We sleep only a little so the previous command is certain to get the file lock first.
sleep 0.1
procdog start slow-health --command "sleep 100" --health-command "sleep 4"
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'false', 'ensure_healthy': True}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.ensure2.lock
procdog (_PID_): monitor: starting with Options(command='sleep 100', health_command='false', health_count=5, health_delay=1.0, ensure_healthy=True, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.ensure2.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check: result: 1
procdog (_PID_): monitor: command 'status': response 'running, health=1, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'wait'
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 0: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 1: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 2: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 3: result: 1
procdog (_PID_): debug: monitor: running health check: command: false
procdog (_PID_): debug: monitor: health check 4: result: 1
procdog (_PID_): monitor: command 'wait': response 'running, health=1, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
procdog (_PID_): debug: command-line options: {'command': 'sleep 100', 'health_command': 'sleep 4'}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='sleep 4', health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: False: /var/tmp/procdog.slow-health.lock
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=0, pid=_PID_

procdog status slow-health
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=False and ensure_healthy=False)
running, health=0, pid=_PID_

procdog stop slow-health
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command=None, health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=False and ensure_healthy=False)
killed, signal=15

# Test --shell argument.
rm -f tmp.stdout.*

procdog start printenv --command "ANIMAL=pangolin printenv" --stdout tmp.stdout.printenv --dir /tmp --shell || expect_error
procdog (_PID_): debug: command-line options: {'command': 'ANIMAL=pangolin printenv', 'dir': '/tmp', 'stdout': 'tmp.stdout.printenv', 'shell': True}
procdog (_PID_): debug: combined options: Options(command='ANIMAL=pangolin printenv', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.printenv', stderr=None, append=False, linger=3.0, strict=False, shell=True)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.printenv.lock
procdog (_PID_): debug: command-line options: {'command': 'ANIMAL=pangolin printenv', 'dir': '/tmp', 'stdout': 'tmp.stdout.printenv', 'shell': True}
procdog (_PID_): debug: combined options: Options(command='ANIMAL=pangolin printenv', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.printenv', stderr=None, append=False, linger=3.0, strict=False, shell=True)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.printenv.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=0' with strict=False and ensure_healthy=False)
exited, returncode=0
(got expected error: status 5)

grep pangolin /tmp/tmp.stdout.printenv
procdog: _TIMESTAMP_ Starting process 'printenv' with options: Options(command='ANIMAL=pangolin printenv', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.printenv', stderr=None, append=False, linger=3.0, strict=False, shell=True)
ANIMAL=pangolin

# Short-lived processes and error conditions.
rm -f tmp.stdout.* tmp.stderr.* tmp.stdin.*

procdog start err1 --command "no-such-command" || expect_error
procdog (_PID_): debug: command-line options: {'command': 'no-such-command'}
procdog (_PID_): debug: combined options: Options(command='no-such-command', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.err1.lock
procdog (_PID_): debug: command-line options: {'command': 'no-such-command'}
procdog (_PID_): debug: combined options: Options(command='no-such-command', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.err1.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': 'no-such-command': no-such-command
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': 'no-such-command': no-such-command
procdog (_PID_): debug: client: exit code 2 (based on 'error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': 'no-such-command': no-such-command' with strict=False and ensure_healthy=False)
error: Failed to start: [Errno 2] No such file or directory: 'no-such-command': 'no-such-command': no-such-command
(got expected error: status 2)

procdog start err2 --command "false" || expect_error
procdog (_PID_): debug: command-line options: {'command': 'false'}
procdog (_PID_): debug: combined options: Options(command='false', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.err2.lock
procdog (_PID_): debug: command-line options: {'command': 'false'}
procdog (_PID_): debug: combined options: Options(command='false', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.err2.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=1
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=1
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=1' with strict=False and ensure_healthy=False)
exited, returncode=1
(got expected error: status 5)

procdog start pwd --command "pwd" --stdout tmp.stdout.pwd || expect_error
procdog (_PID_): debug: command-line options: {'command': 'pwd', 'stdout': 'tmp.stdout.pwd'}
procdog (_PID_): debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.pwd.lock
procdog (_PID_): debug: command-line options: {'command': 'pwd', 'stdout': 'tmp.stdout.pwd'}
procdog (_PID_): debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.pwd.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=0' with strict=False and ensure_healthy=False)
exited, returncode=0
(got expected error: status 5)
tail -1 tmp.stdout.pwd
/tmp/procdog-tests

procdog start pwd --command "pwd" --stdout tmp.stdout.pwd --dir /tmp || expect_error
procdog (_PID_): debug: command-line options: {'command': 'pwd', 'dir': '/tmp', 'stdout': 'tmp.stdout.pwd'}
procdog (_PID_): debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.pwd.lock
procdog (_PID_): debug: command-line options: {'command': 'pwd', 'dir': '/tmp', 'stdout': 'tmp.stdout.pwd'}
procdog (_PID_): debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.pwd.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=0' with strict=False and ensure_healthy=False)
exited, returncode=0
(got expected error: status 5)
tail -1 /tmp/tmp.stdout.pwd
/tmp

# Redirect stdout and stderr. Environment variables.
export TESTENV=wensleydale
procdog start out1 --command 'echo hello $TESTENV' --stdout tmp.stdout.out1 --stderr tmp.stderr.out1 || expect_error
procdog (_PID_): debug: command-line options: {'command': 'echo hello $TESTENV', 'stdout': 'tmp.stdout.out1', 'stderr': 'tmp.stderr.out1'}
procdog (_PID_): debug: combined options: Options(command='echo hello $TESTENV', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.out1.lock
procdog (_PID_): debug: command-line options: {'command': 'echo hello $TESTENV', 'stdout': 'tmp.stdout.out1', 'stderr': 'tmp.stderr.out1'}
procdog (_PID_): debug: combined options: Options(command='echo hello $TESTENV', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.out1.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=0' with strict=False and ensure_healthy=False)
exited, returncode=0
(got expected error: status 5)
sleep 1
cat tmp.stdout.out1
procdog: _TIMESTAMP_ Starting process 'out1' with options: Options(command='echo hello wensleydale', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
hello wensleydale
cat tmp.stderr.out1
procdog: _TIMESTAMP_ Starting process 'out1' with options: Options(command='echo hello wensleydale', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
rm -f tmp.stdout.* tmp.stderr.* tmp.stdin.*

procdog start out1 --command 'echo hello $BADENVVAR' --stdout tmp.stdout.out1 --stderr tmp.stderr.out1 || expect_error
procdog (_PID_): debug: command-line options: {'command': 'echo hello $BADENVVAR', 'stdout': 'tmp.stdout.out1', 'stderr': 'tmp.stderr.out1'}
procdog (_PID_): debug: combined options: Options(command='echo hello $BADENVVAR', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
procdog: error: could not expand environment variable names in command 'echo hello $BADENVVAR': 'BADENVVAR'
Traceback (most recent call last):
  File ".../procdog", line __X, in _expand_variables
    return Template(template_str).substitute(os.environ)
  File ".../string.py", line __X, in substitute
    return self.pattern.sub(convert, self.template)
  File ".../string.py", line __X, in convert
    return str(mapping[named])
  File ".../os.py", line __X, in __getitem__
    raise KeyError(key) from None
KeyError: 'BADENVVAR'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File ".../procdog", line __X, in main
    options = options._replace(command=_expand_variables(options.command),
  File ".../procdog", line __X, in _expand_variables
    raise ValueError("could not expand environment variable names in command '%s': %s" % (template_str, e))
ValueError: could not expand environment variable names in command 'echo hello $BADENVVAR': 'BADENVVAR'
(got expected error: status 3)

# Read from input and write stderr and stdout to same output.
echo input > tmp.stdin.out2
procdog start out2 --command "cat" --stdin tmp.stdin.out2 --stdout tmp.stdout.out2 --stderr tmp.stdout.out2 || expect_error
procdog (_PID_): debug: command-line options: {'command': 'cat', 'stdin': 'tmp.stdin.out2', 'stdout': 'tmp.stdout.out2', 'stderr': 'tmp.stdout.out2'}
procdog (_PID_): debug: combined options: Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.out2.lock
procdog (_PID_): debug: command-line options: {'command': 'cat', 'stdin': 'tmp.stdin.out2', 'stdout': 'tmp.stdout.out2', 'stderr': 'tmp.stdout.out2'}
procdog (_PID_): debug: combined options: Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.out2.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: exited, returncode=0
procdog (_PID_): debug: client: exit code 5 (based on 'exited, returncode=0' with strict=False and ensure_healthy=False)
exited, returncode=0
(got expected error: status 5)
cat tmp.stdin.out2
input
cat tmp.stdout.out2
procdog: _TIMESTAMP_ Starting process 'out2' with options: Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False, shell=False)
input

# Configuration tests.
procdog start conftest --config $config_file
procdog (_PID_): debug: config file options from file _PATH_/procdog.cfg: {'command': 'sleep 100', 'health_command': 'true', 'health_count': 10, 'health_delay': 0.5, 'ensure_healthy': True, 'strict': True}
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.conftest.lock
procdog (_PID_): debug: command-line options: {'command': 'ANIMAL=pangolin printenv', 'dir': '/tmp', 'stdout': 'tmp.stdout.printenv', 'shell': True}
procdog (_PID_): debug: combined options: Options(command='ANIMAL=pangolin printenv', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.printenv', stderr=None, append=False, linger=3.0, strict=False, shell=True)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.printenv.lock
procdog (_PID_): monitor: starting with Options(command='ANIMAL=pangolin printenv', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.printenv', stderr=None, append=False, linger=3.0, strict=False, shell=True)
procdog (_PID_): monitor: listening on /var/tmp/procdog.printenv.sock
procdog (_PID_): monitor: process done (code 0), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: config file options from file _PATH_/procdog.cfg: {'command': 'sleep 100', 'health_command': 'true', 'health_count': 10, 'health_delay': 0.5, 'ensure_healthy': True, 'strict': True}
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.conftest.lock
procdog (_PID_): debug: client: wait: checking for connect...
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: status: running, health=0, pid=_PID_
procdog (_PID_): debug: client: wait: connect success
procdog (_PID_): debug: monitor: ensure_healthy is set, waiting for health
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: wait: running, health=0, pid=_PID_
procdog (_PID_): debug: monitor: ensure_healthy is set and process is still healthy (running, health=0, pid=_PID_)
procdog (_PID_): debug: client: exit code 0 (based on 'running, health=0, pid=_PID_' with strict=True and ensure_healthy=True)
running, health=0, pid=_PID_

procdog stop conftest --config $config_file
procdog (_PID_): debug: config file options from file _PATH_/procdog.cfg: {'command': 'sleep 100', 'health_command': 'true', 'health_count': 10, 'health_delay': 0.5, 'ensure_healthy': True, 'strict': True}
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: connected
procdog (_PID_): debug: client: stop: killed, signal=15
procdog (_PID_): debug: client: exit code 0 (based on 'killed, signal=15' with strict=True and ensure_healthy=True)
killed, signal=15

procdog start conftest_bad --config $config_file || expect_error
procdog (_PID_): debug: command-line options: {'command': 'no-such-command'}
procdog (_PID_): debug: combined options: Options(command='no-such-command', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.err1.lock
procdog (_PID_): monitor: starting with Options(command='no-such-command', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.err1.sock
procdog (_PID_): monitor: Failed to start: [Errno 2] No such file or directory: 'no-such-command': 'no-such-command': no-such-command
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog: error: Not a boolean: not-valid
Traceback (most recent call last):
  File ".../procdog", line __X, in main
    file_options = _read_config_file(args.proc_name, config_file, target_types)
  File ".../procdog", line __X, in _read_config_file
    out[key] = _parse_config(config, proc_name, key, target_types[key])
  File ".../procdog", line __X, in _parse_config
    return config.getboolean(section, option)
  File ".../configparser.py", line __X, in getboolean
    raw=raw, vars=vars, fallback=fallback, **kwargs)
  File ".../configparser.py", line __X, in _get_conv
    **kwargs)
  File ".../configparser.py", line __X, in _get
    return conv(self.get(section, option, **kwargs))
  File ".../configparser.py", line __X, in _convert_to_boolean
    raise ValueError('Not a boolean: %s' % value)
ValueError: Not a boolean: not-valid
(got expected error: status 3)

# --- End of tests ---
procdog (_PID_): debug: command-line options: {'command': 'false'}
procdog (_PID_): debug: combined options: Options(command='false', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.err2.lock
procdog (_PID_): monitor: starting with Options(command='false', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.err2.sock
procdog (_PID_): monitor: process done (code 1), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=1'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=1'
procdog (_PID_): debug: command-line options: {'command': 'pwd', 'stdout': 'tmp.stdout.pwd'}
procdog (_PID_): debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.pwd.lock
procdog (_PID_): monitor: starting with Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.pwd.sock
procdog (_PID_): monitor: process done (code 0), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: command-line options: {'command': 'pwd', 'dir': '/tmp', 'stdout': 'tmp.stdout.pwd'}
procdog (_PID_): debug: combined options: Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.pwd.lock
procdog (_PID_): monitor: starting with Options(command='pwd', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp', stdin=None, stdout='tmp.stdout.pwd', stderr=None, append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.pwd.sock
procdog (_PID_): monitor: process done (code 0), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: command-line options: {'command': 'echo hello $TESTENV', 'stdout': 'tmp.stdout.out1', 'stderr': 'tmp.stderr.out1'}
procdog (_PID_): debug: combined options: Options(command='echo hello $TESTENV', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.out1.lock
procdog (_PID_): monitor: starting with Options(command='echo hello wensleydale', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin=None, stdout='tmp.stdout.out1', stderr='tmp.stderr.out1', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.out1.sock
procdog (_PID_): monitor: process done (code 0), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: command-line options: {'command': 'cat', 'stdin': 'tmp.stdin.out2', 'stdout': 'tmp.stdout.out2', 'stderr': 'tmp.stdout.out2'}
procdog (_PID_): debug: combined options: Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir=None, stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.out2.lock
procdog (_PID_): monitor: starting with Options(command='cat', health_command=None, health_count=5, health_delay=1.0, ensure_healthy=False, dir='/tmp/procdog-tests', stdin='tmp.stdin.out2', stdout='tmp.stdout.out2', stderr='tmp.stdout.out2', append=False, linger=3.0, strict=False, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.out2.sock
procdog (_PID_): monitor: process done (code 0), exiting
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): monitor: command 'status': response 'exited, returncode=0'
procdog (_PID_): debug: config file options from file _PATH_/procdog.cfg: {'command': 'sleep 100', 'health_command': 'true', 'health_count': 10, 'health_delay': 0.5, 'ensure_healthy': True, 'strict': True}
procdog (_PID_): debug: command-line options: {}
procdog (_PID_): debug: combined options: Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir=None, stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): debug: client: acquired lock: True: /var/tmp/procdog.conftest.lock
procdog (_PID_): monitor: starting with Options(command='sleep 100', health_command='true', health_count=10, health_delay=0.5, ensure_healthy=True, dir='/tmp/procdog-tests', stdin=None, stdout=None, stderr=None, append=False, linger=3.0, strict=True, shell=False)
procdog (_PID_): monitor: listening on /var/tmp/procdog.conftest.sock
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'status'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check: result: 0
procdog (_PID_): monitor: command 'status': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'wait'
procdog (_PID_): debug: monitor: running health check: command: true
procdog (_PID_): debug: monitor: health check 0: result: 0
procdog (_PID_): monitor: command 'wait': response 'running, health=0, pid=_PID_'
procdog (_PID_): debug: monitor: listen accept
procdog (_PID_): debug: monitor: received command 'stop'
procdog (_PID_): monitor: process done (code -15), exiting
procdog (_PID_): monitor: command 'stop': response 'killed, signal=15'
